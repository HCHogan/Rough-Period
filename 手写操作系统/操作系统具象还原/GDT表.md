# 段描述符
## 1.1 GDT与LDT
### 1.1.1 段描述符之GDT表 与 LDT表的概述
GDT表

查询inter手册可以得知. 当我们在保护模式下. 进行内存访问的时候 所有的内存访问. 要么通过全局描述符表(GDT) 要么就通过局部描述符表(LDT) 进行访问的. 而 这些描述符表中.记录的都是段描述符 段描述符里面包含了 段的基地址 访问特权 类型 和用法信息. 每个段描述符都会有一个与之相关的段选择子,也叫做段选择符 段选择子 包含的是 GDT 与LDT(与它相关的的段描述符)里面的一个索引. 一个全局或者局部标志 决定了 段选择子 是指向GDT 还是 LDT. 想要访问GDT 或者LDT 要提供 段选择子以及偏移地址. 段选择子只是提供了一个索引.来进行访问GDT 或者LDT中的段描述符的. 而段描述符 包含了线性地址 空间的基地址 , 偏移量 确定了相对与基地址的字节地址.

GDT表或者LDT表的线性地址都存储在 GDTR 寄存器与 LDTR寄存器 中.

通过上面我们可以得出几点概要

保护模式下.我们的内存访问其实都是查表. 查的是GDT 或者 LDT. 如何确定查询的是GDT 还是LDT 取决于段选择子的 全局或者局部的标志位 而查表其实就是 段选择当索引去GDT表中查询. 查到哪一项. 这一项保存的是 段描述符结构
GDT或者LDT表中.保存的是段描述符结构 段描述符里面才真正的 描述了 段的基地址 访问特权 类型 和用法信息
访问GDT或者LDT 就要提供段选择子以及偏移地址.
以上就是对GDT表或者 LDT表的描述 总结来说 GDT或者LDT 就是一块内存. 也可以看成一个数组. 数组的每一项其实保存的都是段描述符 段选择子就是下标

3.1.2 GDTR寄存器与GDT表了解.
根据Inter手册所属. GDTR寄存器 保存了 GDT的 32位基地址 和16位表界限

基地址指的就是GDT从0字节开始的线性地址.可以理解为就是数组首地址.

表界限.可以理解为就是数组的大小. 所以说GDTR 寄存器是一个48位寄存器

按照C语言结构来来表是就如下:
```c
struct GDTR
{
  DWORD *GdtBase,
  SHORT limit;
}
```
LGDT 与SGDT 汇编指令 分别是用来获取和保存 GDTR寄存器的.

电脑开机之后,通电之后.GDT就开始初始化了.

总结:

1.GDTR是一个寄存器.保存的就是GDT的首地址以及一个长度. 根据长度可以确定一个GDT表示的内存有多大

2.GDT是一个数组.数组里面保存的是段描述符结构 请不要搞混概念

在这里我们就可以用驱动程序来读取 GDT了.并且我们进行打印输出即可.

3.1.3 LDTR寄存器与LDT
LDTR寄存器 保存了 16位的段选择子 32位的基地址 16位的段界限(长度) LDT描述符的属性.

LLDT 和 SLDT 指令分别是用来 获取 和设置 LDTR寄存器的.

结构如下:

struct LDTR
{
  WORD select,
DWORD base,
  WORD  Limit,
WORD Attribute,
}
LDTR没有使用.所以简单了解下.

3.2 段选择子
3.2.1 段选择子介绍
上面了解了LDT表. GDT表. 以及分段的概念. 那么就该说一下如何查表. 段选择子是什么.

其实我们说了怎么多. 都是在了解 当汇编指令访问内存的时候 是怎么走的.

比如:

mov ebx,30h
mov fs,bx
官方的说法如下:

段选择子 是一个 16位 的段标识符. 他不是直接指向该段.而是作为一个索引.指向该

段的 段描述符 其实就是下标. 去GDT表查询. 查到段描述符 段描述符才描述了信息.

30就是段选择子. 这里的30赋值给了ebx中的bx位. bx赋值给fs. 可见部分是段选择子.所以会查表

看图了解



分为两个域 一个是 index(索引 3 - 15位表示) 一个是 标记以及特权位

根据官方手册所说. 索引位. 来表示 GDT表中的8192个描述符的某一项. 由此可以得知.GDT表不会超过 8192项 索引值 * 8 来索引 段描述符 由此可以得知. 段描述符是8个字节大小 且GDT表中的每一项是8个字节

手册还是 GDIT 第一项是不可用的. 也就是段选择子为0. TI 位设置为0 则被视为空选择子

当我们查询GDT表的时候如果为索引为0 那么CPU不会产生异常的. 但是如果我们以空选择子来查询的时候得出的段描述符来进行内存访问的时候.就会产生异常. 就会产生一个 通用保护异常.(GP)

还说了 对CS 以及SS赋予一个空选择副是的时候也会产生GP异常.

TI标记位

进行内存访问的时候,为 0 表示查询GDT. 为1则访问LDT表.

RPL 位

特权级别位. 总共三个等级 0 - 3 0为最高特权级. 描述了 RPL 与 CPL 之间的关系. 以及

段选择子所指向的段描述符

看到这里我们可以进行总结了

1.段段选择子其实也是一个结构.表达了 GDT表的索引. 一个标志.查询GDT还是LDT. 一个特权级别.
所以我们可以进行手工解析了.

2.GDT表中的第一项为不可用的.也就是空选择子
比如我电脑上的段选择子. 也就是段的可见部分. 以DS段为例子 段选择子为 0x0023

拆分成二进制

0000 0000 0010 0011    第一次拆分
0000 0000 0000 0       索引 = 0
0                      查询的GDT表
11                     RPL 特权级别  3
总结一下, 查询的索引 = 0; 查询的是GDT表 . RPL 特权级别 = 3;

2. 段描述符
2.1 段描述符介绍
段描述符是一个结构. 占用了8个字节大小 是GDT表或者LDT表中的一个数据结构

其实上面也说了当进行内存访问的时候,段选择子 当索引 查询GDT表.来得出段描述符表.

段描述符表示了 段基地址 段的大小 访问权限. 以及状态等信息.

看一下这个结构体信息



2.2 段描述符属性详解.
2.2.1 段寄存器与段描述符 一一的对应关系
段寄存器中的段属性 与 段描述符中的段属性的对应关系

段寄存器我们知道其结构为

struct set
{
  WORD Selector, //段选择子  16位
  WORD Attribute,//段属性    16位
  DWORD Base,    //段基地址 32位
  DWORD Limit,   //段限长 32位
}
那么段属性与段描述符 是一种怎么样的对应关系?

请不要把 段寄存器结构 与 段描述符搞混

看下图



对应着段描述符的 高4个字节中的 第八位 到 第23位

段寄存器中的 32位的基地址 与 段描述符中的基地址对应关系

段描述符的基地址由三部分组成. 原因是CPU实在16位上扩展的.要兼容16位.32位 64位.所以只能不断扩展

看下图:



分别是由 高4字节的 24 - 31位 4-7位 低四个字节的 16 - 31位来组成的.

所以我们通过位运算.可以拼接处地址. 并且赋值给段寄存器的基地址域

Limit对应

这个就不用说了.看上图就知道. 第四个字节的 0-15位来做成的limit

高地址的 16 - 19位 也是. 合计20个字节

2.2.2 段属性中的位详解
2.2.2.1P位 高四个字节的第15位
p = 1 代表这个段描述符是有效的

p = 0 代表这个段描述符是无效的

2.2.2.2G位 粒度位 高四个字节的第23位
G位 根据inter手册所说如下

G = 0: 代表段limit(限长)是以字节为单位的. 根据段描述符我们知道段限长 为20位组成.

也就是0xFFFFF 大小. 如果G = 0; 那么是以字节为单位. 在 0xFFFFF最大表示了0xFFFFF个大小

意思就是说以字节为单位. 字节 * limit 来表示一个 一个段界限值.

G = 1: 段限长就是表示4kb大小. 4096-1 = 4095 也就是0xFFF 大小. 也就是一个页大小
段限长可以表示为 4kb * limit 来表示一个limit有多大.

2.2.2.3 S位
在系统中段描述符有很多形式.一种是系统段描述符 一种是数据或者代码段描述符

S = 1 表示代码段或者数据段描述符

s = 0 表示系统段描述符

根据G位 DPL位 S位 可以枚举出什么是代码段.什么是数据段.

DPL要么都为1 要么都为0

所以如果是代码段 G DPL S 组合起来 十六进制要么为9 要么为F

S = 1　代码段与数据段中的Type域讲解
TYPE 域

TYPE域 跟S位相关联. 看下TYPE域的4个位表示

S = 1的时候Type如下.是针对 代码或者数据段表示的. S= 0那么则是针对内核.



TYpe 域中的第 11位 = 0 确定了这是数据段

11位 = 1 确定了这是代码段

意思就是说. S位只是确定了你是代码段还是数据段,但是肯定不会是系统段描述符.

而Type域则真正决定了.你是代码段还是数据段.

所以我们可以在确定代码段或者数据段的前提下.精确的遍历出那些是代码段.那些是数据段.

在段描述符的第6个十六进制位 可以看. 入如果 > 9 就是代码段. 否则就是数据段

对于数段而言 控制位如下:

控制位了. E W A

W 表示可写

A 访问位

E 扩展位

A 位表示了你这个段描述符是否访问过.如果访问过.那么就会置1 否则就是0

W 表示可写位. 如果针对这个段描述符写过.则W位置1. 否则如果为0.那么表示这个数据段是不可写的.

E扩展位

扩展位 分为向下扩展 和向上扩展. 具体意思是啥.

首先了解下堆栈段. 堆栈比如是可读写的数据段. 而且大小需要动态变化. 所以我们使用向下扩展.扩展方向 = 1 就是向下扩展的意思. 意思就是ss.base + limit 这块表示的空间. 其余的空间 是有效的. 比如我们读取堆栈.那么除了ss.base可以读.其余空间也是有效的.也是可以读的.

E = 0 向上扩展: 那么意思就是有效空间只有 ss.base + limt空间大小.

如下图:



图是以fs为原型. 第一个表示向上扩展. 有效空间只有 fs.base + limit E = 0

E = 1 向下扩展. 表示有效空间除了fs.base + limit 之外都是可以访问的.

对于代码段而言 控制位如下:

控制位: C R A

A = 访问位. 同数据段一样.

R = 可读位 表示当前这个段是否是可读的.

C = 一致位

C = 1 一致代码段

C = 0 非一致代码段
S = 0 Type域讲解

上面我们说过S = 1 表示代码段域数据段.而且Type域也不同. 那么S = 0则表示是系统段描述符.那么看下如果是系统段描述符

根据Inter手册所属 当S位 = 0; 这个描述符位系统描述符 处理可以识别以下类型的系统描述符

局部描述符 LDT

任务段描述符 TSS

调用们描述符

中断门描述符

陷阱门描述

任务们描述

这些描述又可以分为两大类 一类是系统段描述符 另一个是门描述符.

系统段(LDT TSS) 门就是本身

看下Type解析



如果是系统段.那么Type域就进行组合解析了. 比如序号为11的一项 二进制为 1011 那么它则表示这个描述符为 32位的TSS 并且处于繁忙状态(Busy)

其实也是第五个字节.可以直接看第五个字节的数据表示形式.图片如下


db位

db位主要是影响段寄存器的操作

CS代码段的影响

D = 1 那么我们的汇编就采用32位的寻址方式

D = 0 那么我们的汇编就采用16位的寻址方式.

​ D = 0 汇编伪代码

  ```
mov esp,dword ptr [di - 18] 操作的di 也就是16位寻址 可以用硬编码0x67进行修改来实现这种寻址
```

D = 1

mov esp,dword ptr [ebp - 18]   操作的都是32位的寄存器
​ SS段的影响

​ 堆栈段影响也是分为16位与32位. 32位下.我们 push pop call 都会影响ESP. 也就是D = 1的情况下

​ D = 0的话. 那么影响的就是SP 而不是ESP

​ 向下扩展的数据段

​ 如果D = 1 那么数据段的limit寻址可以到达4GB.

如果D = 0; 那么就只能到达64kb

其实就是 2^32 与 2^16影响. d = 1 那么都按照32位来算. 否则就是按照16位寻址来算.