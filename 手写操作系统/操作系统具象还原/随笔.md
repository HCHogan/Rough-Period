# 操作系统真相还原随笔--By Hank
## 第三章 完善MBR
### 实模式下的call指令
call相当于将下一条指令压入栈 然后jmp到这个位置
### 实模式下的jmp指令
1，16位是模式绝对远地址调用
一般形式
```
call far 段基址（立即数）：段内偏移地址（立即数）
```
如果不加far 操作码是 0x9a。机器码是 0x9a+2 字节的偏移地址+2 字节的段基址
偏移地址在前 段基址在后
2,16位实模式间接绝对近调用
short改为near 16位 占2字节 所以指令占3字节
## 第四章 保护模式入门
### GDT
gdt是一段内存 数组 每个单位是段描述符 8字节
ds等xs:0x9访问的过程:
ds里面存的是段选择字 16位 高13位是8192个索引 低2位是特权级 第三位是ldt or gdt
在进入保护模式的时候 通过lgdt(load gdt)指令将gdt的表的位置(32位)和长度(16位)写入48位的gdtr寄存器
当ti位是0时cpu通过ds寄存器里面的段选择字找到gdt表里面的对应的段描述符 加工变成段基址
有一个程序员不可见的寄存器存着程序员最近使用过的**且整理好的**这个段的信息(这个寄存器为96位)
### LDT
LDT位一个程序的内存分段 其内容和gdt表一样 但是ldt的第0个是可用的
为了防止没有初始化段选择字 gdt表的第0位是不可用的 访问第0个段描述符的时候会跑出GP general protect异常
而ldt表的第0个是可用的 如果要访问ldt表 那TI位是1 不可能有忘记初始化的情况
由于lgt表也是一段内存 这段内存也要在gdt表中注册 注册完了以后要加载ldt表就用lldt (load ldt) +**16位寄存器/内存**来初始化ldtr寄存器(**同样48位**) 以后访问的时候 如果TI位为1 cpu就用ldtr寄存器去ldt表中找对应的段描述符 然后被放在不可见的96位寄存器里

### 保护模式准备
开A20总线
in al,0x92
or al,0000 0010B
out 0x92,al

cr0寄存器置位
mov eax,cr0
or eax,0x00000001
mov cr0,eax

